package main

import (
	"fmt"
	"math"
	"sort"
	"strings"

	"github.com/fenglyu/projecteuler/golang/common"
)

//var DEDUP map[float64]

var g map[string]bool

func printExponent(powers []int) (int, string) {
	var b strings.Builder
	var c = 1
	for _, v := range powers {
		c *= v
	}
	fmt.Fprintf(&b, "%d", c)
	return c, b.String()
}

func equalInt(base int, powers []int, power int) int {

	num := 0
	var sumF, baseF float64

	flag := true
	sort.Ints(powers)

	// iterate different permucation of the array `powers`,
	// so all exponent multiply composition are covered
	// dedup the result
	dedup := make(map[float64]bool)
	for {
		if !flag {
			break
		}

		sumF = 1
		baseF = float64(base)

		//	fmt.Println(powers)
		for i, v := range powers {

			sumF = math.Pow(baseF, float64(v))

			// base > 100 or exponent < 2
			if common.FloatCompare(sumF, 100.0) > 0 || i >= len(powers)-1 {
				break
			}
			// dedup
			if _, ok := dedup[sumF]; ok {
				break
			} else {
				dedup[sumF] = true
			}

			exp, _ := printExponent(powers[i+1:])
			//		fmt.Println(power, sumF, "**", printExponent(powers[i+1:]), "==", base, "**", power, "->", base, powers)
			baseF = sumF

			key_str := fmt.Sprintf("%d%d", int(baseF), exp)
			fmt.Printf("IN -> [%d-%d]\n", int(baseF), exp)
			g[key_str] = true

			num++
		}

		flag = common.NextPermutationV3(powers, 0, len(powers))
	}

	//	fmt.Println(base, power, powers, num)
	return num
}

func main() {

	// store duplicated key/value pairs like
	// (2, 64) == (4, 32) => "432":true
	g = make(map[string]bool)

	m := make(map[int][]int)
	for i := 2; i < 101; i++ {
		res := common.DivisorV3(i)
		if len(res) < 2 {
			continue
		}
		//	fmt.Println("num: ", i, res)
		m[i] = res
	}

	// To store the keys in slice in sorted order
	var keys []int
	for k, _ := range m {
		keys = append(keys, k)
	}

	sort.Ints(keys)
	//	fmt.Println("map: ", m)
	//fmt.Println("keys: ", keys)
	sum := 0
	for j := 2; j <= 100; j++ {
		//j := 2
		for _, v := range keys {
			//v := 12
			//fmt.Println(v)
			key_str := fmt.Sprintf("%d%d", j, v)
			if _, ok := g[key_str]; ok {
				fmt.Printf("[%d-%d]\n", j, v)
				continue
			}
			t := equalInt(j, m[v], v)
			sum += t
		}
	}

	fmt.Println("found: ", sum)
	fmt.Println("sum: ", 99*99-sum)

}

/*

Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
2**2=4,  2**3=8,   2**4=16,  2**5=32
3**2=9,  3**3=27,  3**4=81,  3**5=243
4**2=16, 4**3=64,  4**4=256, 4**5=1024
5**2=25, 5**3=125, 5**4=625, 5**5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

python one-liner
```
>>> len(set(a**b for a in range(2, 101) for b in range(2, 101)))
9183

```
go run  29.go |grep '2 \[' |sort -k8,8n

/*
python 29.py|grep '(2, '  |sort -k4,4n -k2,2n
*/
